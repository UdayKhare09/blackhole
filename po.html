<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Black Hole Simulator</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }
        a {
            color: #61dafb;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">
        <strong>Black Hole Simulator</strong><br>
        - Drag the mouse to orbit the camera.<br>
        - Use the scroll wheel to zoom in and out.<br>
        <p>This simulation uses ray marching in a fragment shader to render the gravitational lensing effect of a black hole on its accretion disk.</p>
    </div>
    <canvas id="glcanvas"></canvas>

    <!-- Vertex Shader: Renders a full-screen quad -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader: The core of the simulation -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        // This matrix transforms from camera space to world space
        uniform mat4 u_invViewMatrix; 
        uniform vec3 u_cameraPosition;

        // --- Constants ---
        const float PI = 3.14159265359;
        const int MAX_STEPS = 150; 
        const float MAX_DIST = 100.0;
        const float STEP_SIZE = 0.25; 
        const float EPSILON = 0.001;

        // --- Black Hole Properties ---
        const float schwarzschildRadius = 1.0; 

        // --- Accretion Disk Properties ---
        const float diskInnerRadius = schwarzschildRadius * 1.5;
        const float diskOuterRadius = schwarzschildRadius * 5.0;
        const float diskHeight = 0.05; // Still used for thickness, but not for main intersection

        // --- Physics ---
        const float G = 1.0; 
        const float M = 1.0;

        /**
         * Simple pseudo-random number generator.
         */
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        /**
         * 2D Noise function based on the random generator.
         */
        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);

            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));

            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        /**
         * Calculates the color of the accretion disk at a given point in space.
         */
        vec3 getDiskColor(vec3 p) {
            float dist = length(p.xz);
            vec2 coords = p.xz;

            float turbulence = noise(coords * 2.0 + u_time * 0.05) * 2.5;
            float rotation_angle = (1.0 / (dist + 0.2)) * (u_time * -0.3 + turbulence);
            float s = sin(rotation_angle);
            float c = cos(rotation_angle);
            mat2 rotation_matrix = mat2(c, -s, s, c);

            vec2 noise_coord = (rotation_matrix * coords) * 3.0;

            float n = 0.0;
            n += 1.0 * noise(noise_coord);
            n += 0.5 * noise(noise_coord * 2.5);
            n += 0.25 * noise(noise_coord * 5.0);
            n /= 1.75;

            float intensity = pow(n, 2.0);
            vec3 color = vec3(1.0, 0.4, 0.1);

            float angle = atan(p.z, p.x);
            float doppler = sin(angle * 3.0 + dist * 0.5) * 0.1;
            color.r += doppler;
            color.b -= doppler;

            float falloff = 1.0 - smoothstep(diskInnerRadius, diskOuterRadius, dist);
            return color * intensity * 2.5 * falloff;
        }
        
        /**
         * Main ray marching function with accurate ray-plane intersection.
         */
        vec3 rayMarch(vec3 rayOrigin, vec3 rayDir) {
            vec3 finalColor = vec3(0.0);
            vec3 p = rayOrigin;

            for (int i = 0; i < MAX_STEPS; i++) {
                vec3 p_prev = p;

                if (length(p) < schwarzschildRadius + EPSILON) {
                    return vec3(0.0); // Hit the event horizon
                }

                // --- Gravitational Lensing ---
                float distToCenterSq = dot(p, p);
                vec3 gravityDir = -normalize(p);
                vec3 acceleration = gravityDir * (G * M) / distToCenterSq;
                rayDir += acceleration * STEP_SIZE;
                rayDir = normalize(rayDir);
                p += rayDir * STEP_SIZE;

                // --- Accurate Ray-Plane Intersection Test for the Disk ---
                // Check if the ray segment from p_prev to p crossed the y=0 plane.
                if (p_prev.y * p.y < 0.0) {
                    // Find the exact intersection point using linear interpolation.
                    float t = -p_prev.y / (p.y - p_prev.y);
                    vec3 intersection_point = p_prev + t * (p - p_prev);

                    // Now check if this precise point is within the disk's bounds.
                    float dist_to_center = length(intersection_point.xz);
                    if (dist_to_center > diskInnerRadius && dist_to_center < diskOuterRadius) {
                        finalColor = getDiskColor(intersection_point);
                        break; // Intersection found, stop marching.
                    }
                }

                if (length(p) > MAX_DIST) {
                    break; // Ray has gone too far.
                }
            }

            return finalColor;
        }

        /**
         * Main function executed for every pixel.
         */
        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
            vec3 rayDir = normalize(vec3(uv, -1.0));
            rayDir = (u_invViewMatrix * vec4(rayDir, 0.0)).xyz;
            vec3 color = rayMarch(u_cameraPosition, rayDir);
            float l = dot(color, vec3(0.21, 0.72, 0.07));
            color += color * l * 0.3;
            color = pow(color, vec3(0.4545));
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        // --- Main JavaScript Logic ---
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glcanvas');
            const gl = canvas.getContext('webgl', { antialias: true });

            if (!gl) {
                alert('Unable to initialize WebGL. Your browser or machine may not support it.');
                return;
            }

            const vsSource = document.getElementById('vertex-shader').textContent;
            const fsSource = document.getElementById('fragment-shader').textContent;
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

            const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'a_position'),
                },
                uniformLocations: {
                    resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),
                    time: gl.getUniformLocation(shaderProgram, 'u_time'),
                    invViewMatrix: gl.getUniformLocation(shaderProgram, 'u_invViewMatrix'),
                    cameraPosition: gl.getUniformLocation(shaderProgram, 'u_cameraPosition'),
                },
            };

            const positionBuffer = initBuffers(gl);

            let camera = {
                azimuth: 0.5,
                elevation: 1.5,
                radius: 12.0,
                minRadius: 4.0,
                maxRadius: 40.0,
                target: [0, 0, 0],
                position: [0, 0, 12]
            };

            let mouse = {
                isDown: false,
                lastX: 0,
                lastY: 0
            };

            canvas.addEventListener('mousedown', (e) => {
                mouse.isDown = true;
                mouse.lastX = e.clientX;
                mouse.lastY = e.clientY;
            });

            canvas.addEventListener('mouseup', () => {
                mouse.isDown = false;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!mouse.isDown) return;
                const dx = e.clientX - mouse.lastX;
                const dy = e.clientY - mouse.lastY;

                camera.azimuth -= dx * 0.005;
                camera.elevation -= dy * 0.005;
                camera.elevation = Math.max(0.01, Math.min(Math.PI - 0.01, camera.elevation));

                mouse.lastX = e.clientX;
                mouse.lastY = e.clientY;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.radius += e.deltaY * 0.01;
                camera.radius = Math.max(camera.minRadius, Math.min(camera.maxRadius, camera.radius));
            }, { passive: false });

            let then = 0;
            function render(now) {
                now *= 0.001; 
                const deltaTime = now - then;
                then = now;
                drawScene(gl, programInfo, positionBuffer, camera, now);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return positionBuffer;
        }

        function drawScene(gl, programInfo, buffer, camera, time) {
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            camera.position[0] = camera.radius * Math.sin(camera.elevation) * Math.cos(camera.azimuth);
            camera.position[1] = camera.radius * Math.cos(camera.elevation);
            camera.position[2] = camera.radius * Math.sin(camera.elevation) * Math.sin(camera.azimuth);

            const viewMatrix = mat4.create();
            mat4.lookAt(viewMatrix, camera.position, camera.target, [0, 1, 0]);
            
            const invViewMatrix = mat4.create();
            mat4.invert(invViewMatrix, viewMatrix);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            gl.useProgram(programInfo.program);

            gl.uniform2f(programInfo.uniformLocations.resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(programInfo.uniformLocations.time, time);
            gl.uniform3fv(programInfo.uniformLocations.cameraPosition, camera.position);
            gl.uniformMatrix4fv(programInfo.uniformLocations.invViewMatrix, false, invViewMatrix);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        // --- Minimal gl-matrix library functions to keep it self-contained ---
        const mat4 = {
            create: function() { return new Float32Array(16); },
            lookAt: function(out, eye, center, up) {
                let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                let eyex = eye[0], eyey = eye[1], eyez = eye[2];
                let upx = up[0], upy = up[1], upz = up[2];
                let centerx = center[0], centery = center[1], centerz = center[2];
                if (Math.abs(eyex - centerx) < 1e-6 && Math.abs(eyey - centery) < 1e-6 && Math.abs(eyez - centerz) < 1e-6) {
                    return this.identity(out);
                }
                z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
                len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len; z1 *= len; z2 *= len;
                x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
                len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                if (!len) { x0 = 0; x1 = 0; x2 = 0; } else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }
                y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
                len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                if (!len) { y0 = 0; y1 = 0; y2 = 0; } else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }
                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
                out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
                out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out[15] = 1;
                return out;
            },
            identity: function(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            },
            invert: function(out, a) {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b00 = a00 * a11 - a01 * a10;
                let b01 = a00 * a12 - a02 * a10;
                let b02 = a00 * a13 - a03 * a10;
                let b03 = a01 * a12 - a02 * a11;
                let b04 = a01 * a13 - a03 * a11;
                let b05 = a02 * a13 - a03 * a12;
                let b06 = a20 * a31 - a21 * a30;
                let b07 = a20 * a32 - a22 * a30;
                let b08 = a20 * a33 - a23 * a30;
                let b09 = a21 * a32 - a22 * a31;
                let b10 = a21 * a33 - a23 * a31;
                let b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) { return null; }
                det = 1.0 / det;
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return out;
            }
        };
    </script>
</body>
</html>
