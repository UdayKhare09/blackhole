<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Black Hole Simulator with Planets</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            background-color: #000;
            color: #fff;
            font-family: 'Inter', sans-serif;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            font-size: 14px;
            max-width: 320px;
            z-index: 5;
        }
        #controls {
            margin-top: 8px;
        }
        .row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 6px 0;
        }
        .row label {
            min-width: 110px;
        }
        .row input[type="range"] {
            width: 140px;
        }
        .toggles {
            display: grid;
            grid-template-columns: repeat(2, auto);
            gap: 6px 12px;
            margin-top: 10px;
        }
        .toggles label {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            cursor: pointer;
        }
        #fps {
            margin-top: 8px;
            font-variant-numeric: tabular-nums;
            opacity: 0.9;
        }
        a {
            color: #61dafb;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="info">
        <strong>Black Hole Simulator</strong><br>
        - Drag mouse or a single finger to orbit the camera.<br>
        - Scroll wheel or pinch to zoom.<br>
    <p>This simulation renders the gravitational lensing of a black hole. The accretion disk is semi-transparent so you can see planets through it, and its emitted light is bent around the hole.</p>
    <div id="controls">
        <div class="row">
            <label for="mass">Mass</label>
            <input id="mass" type="range" min="0.1" max="5" step="0.01" value="1.0" />
            <span id="massVal">1.00</span>
        </div>
        <div class="row">
            <label for="diskRadius">Disk radius</label>
            <input id="diskRadius" type="range" min="2" max="30" step="0.1" value="8.0" />
            <span id="diskRadVal">8.0</span>
        </div>
        <div class="toggles">
            <label><input type="checkbox" id="toggleStarfield" checked /> Starfield</label>
            <label><input type="checkbox" id="togglePlanets" checked /> Planets</label>
            <label><input type="checkbox" id="toggleDisk" checked /> Accretion disk</label>
            <label><input type="checkbox" id="toggleLensing" checked /> Lensing</label>
        </div>
        <div id="fps">FPS: --</div>
    </div>
    </div>
    <canvas id="glcanvas"></canvas>

    <!-- Vertex Shader: Renders a full-screen quad -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader: The core of the simulation -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform mat4 u_invViewMatrix; 
        uniform vec3 u_cameraPosition;
    uniform float u_mass;
    uniform float u_schwarzschildRadius;
    uniform float u_diskInnerRadius;
    uniform float u_diskOuterRadius;
    uniform int u_enableStarfield; // 1=on, 0=off
    uniform int u_enablePlanets;   // 1=on, 0=off
    uniform int u_enableDisk;      // 1=on, 0=off
    uniform int u_enableLensing;   // 1=on, 0=off
    // Adaptive marching controls
    uniform float u_stepSize;       // base step size (scene units)
    uniform int   u_maxSteps;       // dynamic max steps (<= MAX_STEPS)
    uniform float u_farDist;        // escape distance
    uniform float u_lensMaxRadius;  // radius beyond which lensing is negligible

        // --- Constants ---
        const float PI = 3.14159265359;
    const int MAX_STEPS = 300; // Compile-time cap for WebGL; runtime uses u_maxSteps
        const float MAX_DIST = 100.0; // fallback
        const float EPSILON = 0.001;

    // --- Black Hole and Disk Properties (controlled via UI) ---
    // Note: disk modeled as infinitesimally thin (y=0) plane.

        // --- Planet Properties ---
    const float planet1_orbitRadius = 18.0;
        const float planet1_radius = 0.4;
        const float planet1_speed = 0.1;
        const vec3  planet1_color = vec3(0.8, 0.3, 0.1);

    const float planet2_orbitRadius = 30.0;
        const float planet2_radius = 1.0;
        const float planet2_speed = 0.05;
        const vec3  planet2_color_base = vec3(0.3, 0.4, 0.7);

    // --- Physics ---
    const float G = 1.0; // scaled units

        // --- Utility Functions ---
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        float noise(vec2 st) {
            vec2 i = floor(st);
            vec2 f = fract(st);
            float a = random(i);
            float b = random(i + vec2(1.0, 0.0));
            float c = random(i + vec2(0.0, 1.0));
            float d = random(i + vec2(1.0, 1.0));
            vec2 u = f * f * (3.0 - 2.0 * f);
            return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
        }

        // --- Procedural Starfield (background) ---
        // Crisper stars with soft halos and a subtle nebula band.
        float fbm(vec2 p) {
            float a = 0.5;
            float f = 0.0;
            float sum = 0.0;
            for (int k = 0; k < 4; k++) {
                f += a * noise(p);
                sum += a;
                p = p * 2.03 + vec2(17.7, 11.3);
                a *= 0.5;
            }
            return (sum > 0.0) ? (f / sum) : 0.0;
        }

    vec3 starField(vec3 rd, float t) {
            rd = normalize(rd);
            // Spherical mapping (longitude/latitude)
            float lon = atan(rd.z, rd.x); // -PI..PI
            float lat = asin(clamp(rd.y, -1.0, 1.0)); // -PI/2..PI/2
            vec2 uv = vec2(lon / (2.0 * PI) + 0.5, lat / PI + 0.5);

            // Star grid resolution controls density (more cells -> more potential stars)
            const vec2 GRID = vec2(520.0, 260.0);
            vec2 gUV = uv * GRID;
            vec2 baseCell = floor(gUV);
            vec2 f = fract(gUV);

            vec3 color = vec3(0.0);

            // Sample 3x3 neighbor cells for stars near borders
            for (int j = -1; j <= 1; j++) {
                for (int i = -1; i <= 1; i++) {
                    vec2 cid = baseCell + vec2(float(i), float(j));
                    // Random star position within the cell
                    vec2 off = vec2(
                        random(cid + vec2(13.1, 17.7)),
                        random(cid + vec2(27.3, 39.5))
                    );
                    vec2 d = (vec2(float(i), float(j)) + off) - f;
                    float dist = length(d);

                    // Size distribution: many tiny, few larger (smaller overall for sharper look)
                    float sizeRnd = random(cid + vec2(3.7, 5.1));
                    float size = 0.018 + 0.12 * sizeRnd * sizeRnd;

                    // Brightness distribution: heavy-tailed, with rare bright stars
                    float bRnd = random(cid + vec2(1.3, 2.1));
                    float baseB = pow(bRnd, 10.0);
                    float rare = step(0.985, random(cid + vec2(4.2, 7.9)));
                    baseB += rare * 0.6; // occasional bright pop

                    // Twinkle: subtle temporal modulation per star
                    float twR = random(cid + vec2(9.2, 6.4));
                    float tw = 0.88 + 0.22 * sin(t * (5.0 + 11.0 * twR) + twR * 6.28318);

                    // Star profile: sharp core + soft halo
                    float core = smoothstep(size, 0.0, dist);
                    core = core * core; // sharpen
                    float halo = smoothstep(2.5 * size, 0.0, dist) * 0.35;
                    float starM = core + halo;
                    float intensity = baseB * starM * tw;

                    // Temperature-based coloration (blue-white to warm)
                    float temp = random(cid + vec2(2.7, 8.9));
                    vec3 starCol = mix(vec3(1.0, 0.92, 0.86), vec3(0.75, 0.86, 1.0), temp);
                    color += intensity * starCol;
                }
            }

            // Subtle Milky Way-like band and wispy nebula
            vec3 galN = normalize(vec3(0.0, 0.2, 1.0));
            float band = pow(1.0 - abs(dot(rd, galN)), 2.0);

            // Nebula noise with gentle variation, concentrated near the band
            // Align noise to sky UV to avoid stretching at poles
            float nebBase = fbm(uv * vec2(8.0, 4.0));
            float nebDetail = fbm((uv + vec2(0.17, 0.03)) * vec2(16.0, 8.0));
            float nebMask = smoothstep(0.55, 0.9, band) * smoothstep(0.35, 0.85, nebBase);
            float neb = clamp(0.0 + 0.9 * nebBase + 0.4 * nebDetail, 0.0, 1.6) * nebMask;

            // Soft color blend for nebula (very subtle)
            vec3 nebColA = vec3(0.12, 0.16, 0.22);
            vec3 nebColB = vec3(0.18, 0.12, 0.20);
            vec3 nebula = mix(nebColA, nebColB, nebDetail) * (0.06 * neb);
            color += nebula;

            // Gentle tone mapping for the background
            color = color / (1.0 + color);
            return color;
        }

        /**
         * Calculates the color of a planet if the ray hits one.
         * Returns vec4(color, 1.0) on hit, vec4(0.0) on miss.
         * The 'w' component is used as a hit flag.
         */
        vec4 getPlanetColor(vec3 p) {
            if (u_enablePlanets == 0) {
                return vec4(0.0);
            }
            // Planet 1 (Rocky Planet)
            float angle1 = u_time * planet1_speed;
            vec3 planet1_pos = vec3(cos(angle1) * planet1_orbitRadius, 0.0, sin(angle1) * planet1_orbitRadius);
            
            if (length(p - planet1_pos) < planet1_radius) {
                // Simple lighting: brighter on the side facing the center (accretion disk)
                vec3 normal = normalize(p - planet1_pos);
                vec3 lightDir = normalize(-planet1_pos); // Light from the center
                float diffuse = max(0.0, dot(normal, lightDir)) * 0.7 + 0.3;
                return vec4(planet1_color * diffuse, 1.0);
            }

            // Planet 2 (Gas Giant)
            float angle2 = u_time * planet2_speed + 2.5; // Offset start angle
            vec3 planet2_pos = vec3(cos(angle2) * planet2_orbitRadius, 0.0, sin(angle2) * planet2_orbitRadius);

            if (length(p - planet2_pos) < planet2_radius) {
                vec3 normal = normalize(p - planet2_pos);
                vec3 lightDir = normalize(-planet2_pos);
                float diffuse = max(0.0, dot(normal, lightDir)) * 0.6 + 0.4;

                // Add some noise for texture/bands
                float n = noise(p.xy * 3.0) * 0.5 + noise(p.yz * 6.0) * 0.5;
                vec3 texColor = mix(planet2_color_base, vec3(0.9), n);

                return vec4(texColor * diffuse, 1.0);
            }

            return vec4(0.0); // No hit
        }

        /**
         * Sample the accretion disk at a point: returns emissive color and alpha.
         * The disk is modeled as a thin, semi-transparent, glowing plane at y=0 between inner/outer radii.
         */
        vec4 getDiskSample(vec3 p) {
            // Polar setup (no direct use of angle to avoid seam)
            vec2 xz = p.xz;
            float r = length(xz);
            vec2 e_r = (r > 1e-4) ? xz / r : vec2(1.0, 0.0);
            vec2 e_t = vec2(-e_r.y, e_r.x);

            // Keplerian angular rotation: use thetaFlow to rotate pattern rigidly per-radius
            float theta = atan(xz.y, xz.x);
            float omega = 1.6 * pow(max(r, 0.25), -1.5); // angular velocity ~ r^-1.5
            float thetaFlow = theta - u_time * omega;

            // Seam-free polar noise: use log(r) and sin/cos(thetaFlow)
            float logr = log(max(r, 0.0007));
            float n = 0.0;
            n += 1.00 * noise(vec2(logr * 2.7,           sin(thetaFlow)));
            n += 0.50 * noise(vec2(logr * 5.11 + 17.0,   cos(thetaFlow)));
            n += 0.25 * noise(vec2(logr * 9.30 - 11.0,   sin(thetaFlow * 2.0)));
            n = clamp(n / 1.75, 0.0, 1.0);

            // Spiral arm modulation (rotate with thetaFlow to remain stable)
            float arms = 3.0; // number of arms
            float pitch = 4.0; // spiral tightness
            float spiralPhase = arms * (thetaFlow + log(max(r, 0.0005)) * pitch);
            float armMask = pow(0.5 + 0.5 * cos(spiralPhase), 2.0);
            // Blend arm contrast stronger inside, softer outside
            float radial = smoothstep(u_diskInnerRadius, u_diskOuterRadius, r);
            float armGain = mix(1.35, 1.1, radial);
            float intensity = pow(n, 1.5) * armGain * mix(0.7, 1.2, armMask) * (1.15 - 0.65 * radial);

            // Temperature/brightness gradient (hot inner -> warm outer)
            vec3 colInner = vec3(0.98, 0.98, 1.0);   // blue-white hot
            vec3 colMid   = vec3(1.0, 0.85, 0.55);   // golden
            vec3 colOuter = vec3(1.0, 0.55, 0.22);   // warm orange
            vec3 color = mix(colInner, colMid, smoothstep(0.0, 0.6, radial));
            color = mix(color, colOuter, smoothstep(0.4, 1.0, radial));

            // Doppler tint from local orbital velocity relative to view
            float v = 0.8 * pow(max(r, 0.25), -0.5); // orbital speed ~ r^-0.5
            vec3 velDir3 = normalize(vec3(-p.z, 0.0, p.x));
            vec3 viewDir = normalize(u_cameraPosition - p);
            float dop = clamp(dot(velDir3, viewDir) * v, -1.0, 1.0);
            color.r *= (1.0 - 0.35 * max(dop, 0.0));
            color.b *= (1.0 + 0.55 * max(-dop, 0.0));

            // Emissive and alpha with radial falloff
            float falloff = 1.0 - smoothstep(u_diskInnerRadius, u_diskOuterRadius, r);
            vec3 emissive = color * intensity * (2.2 + 1.3 * (1.0 - radial)) * falloff;
            float baseAlpha = 0.33;
            float alpha = baseAlpha * falloff * clamp(intensity * (1.1 + 0.4 * (1.0 - radial)), 0.1, 1.0);
            return vec4(emissive, alpha);
        }
        
        /**
         * Main ray marching function with planet detection.
         */
    vec3 rayMarch(vec3 rayOrigin, vec3 rayDir) {
            vec3 accColor = vec3(0.0); // accumulated color along the ray
            float transmittance = 1.0; // remaining transparency (1 means fully visible background)
            vec3 p = rayOrigin;
            float farDist = (u_farDist > 0.0) ? u_farDist : MAX_DIST;

            for (int i = 0; i < MAX_STEPS; i++) {
                if (i >= u_maxSteps) break;
                vec3 p_prev = p;

                // Opaque planet hit: composite and stop
                vec4 planetHitColor = getPlanetColor(p);
                if (planetHitColor.w > 0.5) {
            accColor += transmittance * planetHitColor.rgb;
            return accColor;
                }

                // Event horizon absorbs remaining light: stop
                if (u_enableLensing == 1) {
                    if (length(p) < u_schwarzschildRadius + EPSILON) {
                        return accColor;
                    }
                }

                // Apply gravitational lensing (curved geodesic approximation)
                float r = length(p);
                float distToCenterSq = max(r * r, 1e-4);
                // Adaptive step: take larger steps far from disk and outside lensing region
                float step = u_stepSize;
                // Increase step with distance from center
                step += step * smoothstep(u_diskOuterRadius + 2.0, farDist, r) * 2.5;
                // Increase step when far from the disk plane (|y| large)
                step *= 1.0 + 1.2 * smoothstep(0.5, 3.0, abs(p.y));

                if (u_enableLensing == 1 && r < u_lensMaxRadius) {
                    vec3 gravityDir = (r > 1e-6) ? -p / r : vec3(0.0, 0.0, 0.0);
                    vec3 acceleration = gravityDir * (G * u_mass) / distToCenterSq;
                    rayDir = normalize(rayDir + acceleration * step);
                }
                p += rayDir * step;

                // Thin-disk intersection via sign change on y
                if (u_enableDisk == 1 && p_prev.y * p.y < 0.0) {
                    float t = -p_prev.y / (p.y - p_prev.y);
                    vec3 hit = p_prev + t * (p - p_prev);
                    float r = length(hit.xz);
                    if (r > u_diskInnerRadius && r < u_diskOuterRadius) {
                        vec4 disk = getDiskSample(hit);
                        // Front-to-back compositing
                        accColor += transmittance * disk.rgb;
                        transmittance *= (1.0 - disk.a);
                        // Early out if nearly opaque after accumulation
                        if (transmittance < 0.02) {
                            return accColor;
                        }
                    }
                }

                if (length(p) > farDist) {
                    // Ray escaped scene bounds: composite starfield using bent direction
                    if (u_enableStarfield == 1) {
                        accColor += transmittance * starField(rayDir, u_time);
                    }
                    return accColor;
                }
            }

            // If we reached max steps without escaping, add background as well
            if (u_enableStarfield == 1) {
                accColor += transmittance * starField(rayDir, u_time);
            }
            return accColor;
        }

        /**
         * Main function executed for every pixel.
         */
        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
            vec3 rayDir = normalize(vec3(uv, -1.0));
            rayDir = (u_invViewMatrix * vec4(rayDir, 0.0)).xyz;
            // Early-out: starfield only, no marching needed
            if (u_enableStarfield == 1 && u_enablePlanets == 0 && u_enableDisk == 0 && u_enableLensing == 0) {
                vec3 bg = starField(rayDir, u_time);
                bg = pow(bg, vec3(0.4545));
                gl_FragColor = vec4(bg, 1.0);
                return;
            }
            // If literally everything is off, return black
            if (u_enableStarfield == 0 && u_enablePlanets == 0 && u_enableDisk == 0 && u_enableLensing == 0) {
                gl_FragColor = vec4(0.0);
                return;
            }
            vec3 color = rayMarch(u_cameraPosition, rayDir);
            float l = dot(color, vec3(0.21, 0.72, 0.07));
            color += color * l * 0.3; // Bloom/glow effect
            color = pow(color, vec3(0.4545)); // Gamma correction
            gl_FragColor = vec4(color, 1.0);
        }
    </script>

    <script>
        // --- Main JavaScript Logic ---
        window.onload = main;

        function main() {
            const canvas = document.getElementById('glcanvas');
            const gl = canvas.getContext('webgl', { antialias: true });

            if (!gl) {
                alert('Unable to initialize WebGL. Your browser or machine may not support it.');
                return;
            }

            const vsSource = document.getElementById('vertex-shader').textContent;
            const fsSource = document.getElementById('fragment-shader').textContent;
            const shaderProgram = initShaderProgram(gl, vsSource, fsSource);

        const programInfo = {
                program: shaderProgram,
                attribLocations: {
                    vertexPosition: gl.getAttribLocation(shaderProgram, 'a_position'),
                },
                uniformLocations: {
                    resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),
                    time: gl.getUniformLocation(shaderProgram, 'u_time'),
                    invViewMatrix: gl.getUniformLocation(shaderProgram, 'u_invViewMatrix'),
                    cameraPosition: gl.getUniformLocation(shaderProgram, 'u_cameraPosition'),
            mass: gl.getUniformLocation(shaderProgram, 'u_mass'),
            schwarzschildRadius: gl.getUniformLocation(shaderProgram, 'u_schwarzschildRadius'),
            diskInnerRadius: gl.getUniformLocation(shaderProgram, 'u_diskInnerRadius'),
            diskOuterRadius: gl.getUniformLocation(shaderProgram, 'u_diskOuterRadius'),
            enableStarfield: gl.getUniformLocation(shaderProgram, 'u_enableStarfield'),
            enablePlanets: gl.getUniformLocation(shaderProgram, 'u_enablePlanets'),
            enableDisk: gl.getUniformLocation(shaderProgram, 'u_enableDisk'),
            enableLensing: gl.getUniformLocation(shaderProgram, 'u_enableLensing'),
            stepSize: gl.getUniformLocation(shaderProgram, 'u_stepSize'),
            maxSteps: gl.getUniformLocation(shaderProgram, 'u_maxSteps'),
            farDist: gl.getUniformLocation(shaderProgram, 'u_farDist'),
            lensMaxRadius: gl.getUniformLocation(shaderProgram, 'u_lensMaxRadius'),
                },
            };

            const positionBuffer = initBuffers(gl);

            let camera = {
                azimuth: 0.5,
                elevation: 1.5,
                radius: 15.0, // Adjusted initial zoom
                minRadius: 4.0,
                maxRadius: 50.0, // Increased max zoom
                target: [0, 0, 0],
                position: [0, 0, 15]
            };

            // --- Mouse Controls ---
            let mouse = { isDown: false, lastX: 0, lastY: 0 };
            canvas.addEventListener('mousedown', (e) => {
                mouse.isDown = true;
                mouse.lastX = e.clientX;
                mouse.lastY = e.clientY;
            });
            canvas.addEventListener('mouseup', () => { mouse.isDown = false; });
            canvas.addEventListener('mousemove', (e) => {
                if (!mouse.isDown) return;
                const dx = e.clientX - mouse.lastX;
                const dy = e.clientY - mouse.lastY;
                camera.azimuth -= dx * 0.005;
                camera.elevation -= dy * 0.005;
                camera.elevation = Math.max(0.01, Math.min(Math.PI - 0.01, camera.elevation));
                mouse.lastX = e.clientX;
                mouse.lastY = e.clientY;
            });
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                camera.radius += e.deltaY * 0.02;
                camera.radius = Math.max(camera.minRadius, Math.min(camera.maxRadius, camera.radius));
            }, { passive: false });

            // --- Touch Controls ---
            let touch = { lastX: 0, lastY: 0, lastPinchDist: 0 };
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    touch.lastX = e.touches[0].clientX;
                    touch.lastY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    touch.lastPinchDist = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: false });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const dx = e.touches[0].clientX - touch.lastX;
                    const dy = e.touches[0].clientY - touch.lastY;
                    camera.azimuth -= dx * 0.005;
                    camera.elevation -= dy * 0.005;
                    camera.elevation = Math.max(0.01, Math.min(Math.PI - 0.01, camera.elevation));
                    touch.lastX = e.touches[0].clientX;
                    touch.lastY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const pinchDist = Math.sqrt(dx * dx + dy * dy);
                    const deltaDist = pinchDist - touch.lastPinchDist;
                    camera.radius -= deltaDist * 0.1;
                    camera.radius = Math.max(camera.minRadius, Math.min(camera.maxRadius, camera.radius));
                    touch.lastPinchDist = pinchDist;
                }
            }, { passive: false });
            canvas.addEventListener('touchend', (e) => { e.preventDefault(); }, { passive: false });

            // --- UI State ---
            const massSlider = document.getElementById('mass');
            const massVal = document.getElementById('massVal');
            const diskSlider = document.getElementById('diskRadius');
            const diskVal = document.getElementById('diskRadVal');
            const fpsEl = document.getElementById('fps');
            const toggleStarfield = document.getElementById('toggleStarfield');
            const togglePlanets = document.getElementById('togglePlanets');
            const toggleDisk = document.getElementById('toggleDisk');
            const toggleLensing = document.getElementById('toggleLensing');

            const params = {
                mass: parseFloat(massSlider.value),
                schwarzschild: parseFloat(massSlider.value), // tie Rs to mass in scaled units
                diskOuter: parseFloat(diskSlider.value),
                starfieldOn: true,
                planetsOn: true,
                diskOn: true,
                lensingOn: true,
            };

            function updateLabels() {
                massVal.textContent = params.mass.toFixed(2);
                diskVal.textContent = params.diskOuter.toFixed(1);
            }
            updateLabels();

            massSlider.addEventListener('input', () => {
                params.mass = parseFloat(massSlider.value);
                params.schwarzschild = params.mass;
                updateLabels();
            });
            diskSlider.addEventListener('input', () => {
                params.diskOuter = parseFloat(diskSlider.value);
                updateLabels();
            });

            toggleStarfield.addEventListener('change', () => {
                params.starfieldOn = toggleStarfield.checked;
            });
            togglePlanets.addEventListener('change', () => {
                params.planetsOn = togglePlanets.checked;
            });
            toggleDisk.addEventListener('change', () => {
                params.diskOn = toggleDisk.checked;
            });
            toggleLensing.addEventListener('change', () => {
                params.lensingOn = toggleLensing.checked;
            });

            // --- FPS ---
            let then = 0;
            let fpsEMA = 0; // exponential moving average for stability
            function render(now) {
                now *= 0.001; 
                const deltaTime = now - then;
                then = now;
                // Update FPS display
                if (deltaTime > 0) {
                    const fps = 1.0 / deltaTime;
                    fpsEMA = fpsEMA ? (fpsEMA * 0.9 + fps * 0.1) : fps; // smooth
                    fpsEl.textContent = `FPS: ${fpsEMA.toFixed(1)}`;
                }

                drawScene(gl, programInfo, positionBuffer, camera, now, params, fpsEMA);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }

        function initBuffers(gl) {
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0];
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            return positionBuffer;
        }

    function drawScene(gl, programInfo, buffer, camera, time, params, fps) {
            resizeCanvasToDisplaySize(gl.canvas);
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            camera.position[0] = camera.radius * Math.sin(camera.elevation) * Math.cos(camera.azimuth);
            camera.position[1] = camera.radius * Math.cos(camera.elevation);
            camera.position[2] = camera.radius * Math.sin(camera.elevation) * Math.sin(camera.azimuth);

            const viewMatrix = mat4.create();
            mat4.lookAt(viewMatrix, camera.position, camera.target, [0, 1, 0]);
            
            const invViewMatrix = mat4.create();
            mat4.invert(invViewMatrix, viewMatrix);

            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);
            gl.useProgram(programInfo.program);

            gl.uniform2f(programInfo.uniformLocations.resolution, gl.canvas.width, gl.canvas.height);
            gl.uniform1f(programInfo.uniformLocations.time, time);
            gl.uniform3fv(programInfo.uniformLocations.cameraPosition, camera.position);
            gl.uniformMatrix4fv(programInfo.uniformLocations.invViewMatrix, false, invViewMatrix);

            // Runtime-adjustable uniforms
            gl.uniform1f(programInfo.uniformLocations.mass, params.mass);
            gl.uniform1f(programInfo.uniformLocations.schwarzschildRadius, params.schwarzschild);
            gl.uniform1f(programInfo.uniformLocations.diskInnerRadius, 1.5 * params.schwarzschild);
            gl.uniform1f(programInfo.uniformLocations.diskOuterRadius, params.diskOuter);
            gl.uniform1i(programInfo.uniformLocations.enableStarfield, params.starfieldOn ? 1 : 0);
            gl.uniform1i(programInfo.uniformLocations.enablePlanets, params.planetsOn ? 1 : 0);
            gl.uniform1i(programInfo.uniformLocations.enableDisk, params.diskOn ? 1 : 0);
            gl.uniform1i(programInfo.uniformLocations.enableLensing, params.lensingOn ? 1 : 0);

            // Adaptive marching params based on toggles and simple FPS heuristic
            let baseStep = params.lensingOn ? 0.25 : 0.45;
            if (!params.diskOn) baseStep *= 1.15;
            if (!params.planetsOn) baseStep *= 1.15;
            // If FPS drops, gently increase step to reduce work; if high FPS, nudge down
            if (fps) {
                if (fps < 30) baseStep *= 1.2;
                else if (fps > 55) baseStep *= 0.9;
            }
            baseStep = Math.min(Math.max(baseStep, 0.15), 0.8);
            const maxSteps = params.lensingOn ? 220 : 120;
            const farDist = 100.0;
            const lensMaxRadius = params.lensingOn ? (params.diskOuter * 2.0 + 6.0) : 0.0;

            gl.uniform1f(programInfo.uniformLocations.stepSize, baseStep);
            gl.uniform1i(programInfo.uniformLocations.maxSteps, maxSteps);
            gl.uniform1f(programInfo.uniformLocations.farDist, farDist);
            gl.uniform1f(programInfo.uniformLocations.lensMaxRadius, lensMaxRadius);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        function initShaderProgram(gl, vsSource, fsSource) {
            const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const shaderProgram = gl.createProgram();
            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                return null;
            }
            return shaderProgram;
        }

        function loadShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width  !== displayWidth || canvas.height !== displayHeight) {
                canvas.width  = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }

        // --- Minimal gl-matrix library functions to keep it self-contained ---
        const mat4 = {
            create: function() { return new Float32Array(16); },
            lookAt: function(out, eye, center, up) {
                let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
                let eyex = eye[0], eyey = eye[1], eyez = eye[2];
                let upx = up[0], upy = up[1], upz = up[2];
                let centerx = center[0], centery = center[1], centerz = center[2];
                if (Math.abs(eyex - centerx) < 1e-6 && Math.abs(eyey - centery) < 1e-6 && Math.abs(eyez - centerz) < 1e-6) { return this.identity(out); }
                z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
                len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
                z0 *= len; z1 *= len; z2 *= len;
                x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
                len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
                if (!len) { x0 = 0; x1 = 0; x2 = 0; } else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }
                y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
                len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
                if (!len) { y0 = 0; y1 = 0; y2 = 0; } else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }
                out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
                out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
                out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
                out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
                out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
                out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
                out[15] = 1;
                return out;
            },
            identity: function(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
                return out;
            },
            invert: function(out, a) {
                let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                let b00 = a00 * a11 - a01 * a10, b01 = a00 * a12 - a02 * a10, b02 = a00 * a13 - a03 * a10, b03 = a01 * a12 - a02 * a11, b04 = a01 * a13 - a03 * a11, b05 = a02 * a13 - a03 * a12;
                let b06 = a20 * a31 - a21 * a30, b07 = a20 * a32 - a22 * a30, b08 = a20 * a33 - a23 * a30, b09 = a21 * a32 - a22 * a31, b10 = a21 * a33 - a23 * a31, b11 = a22 * a33 - a23 * a32;
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) { return null; }
                det = 1.0 / det;
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
                return out;
            }
        };
    </script>
</body>
</html>
